\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics

%% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
%% `natbio-farve` to use SCIENCE's new colors and logo.
\def \ColourPDF {include/ku-farve}

%% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
\def \TitlePDF   {include/ku-en}  % University of Copenhagen

\title{
  \vspace{3cm}
  \Huge{Optimizing SasView models} \\
  \Large{Enhancing performance by rewriting kernels from OpenCL/OpenMP to Futhark}
}

\author{
  \Large{Mikkel Storgaard Knudsen}
  \\ \texttt{mikkelstorgaard@gmail.com} \\
  \\
  \Large{Supervisor}
  \\ Martin Elsman
  \\ \texttt{mael@di.ku.dk} \\
}

\date{
    \today
}

\newcommand{\sasmodels}{\textit{SasModels}}
\newcommand{\sasview}{\textit{SasView}}
\newcommand{\iq}{\textit{I(q)}}
\newcommand{\foriq}{\texttt{for\_iq}}
\newcommand{\hasiq}{\texttt{has\_iq}}
\begin{document}


\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]{\ColourPDF}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]{\ColourPDF}}}

\AddToShipoutPicture*{\put(0,0){\includegraphics*{\TitlePDF}}}

\clearpage\maketitle
\thispagestyle{empty}

\section*{Abstract}

\newpage

\section{Introduction}
\subsection{Goal and motivation}
\textit{SasView} is a Small Angle Scattering (SAS) analysis package for the analysis of
1D and 2D scattering data directly in inverse space.
As \textit{SasView} is given data, it performs its analyses by running the input data
through theory models provided by the standalone module \textit{Sasmodels}.
\\
\\
The \textit{Sasmodels} models utilizes a set of kernels, which are implemented
in both OpenCL and OpenMP.
However, benchmark
comparisons\footnote{https://futhark-lang.org/performance.html} between the
parallel algorithm library \textit{Thrust} (implemented in C++/CUDA), and the
array programming language Futhark, shows that there might severe speed
improvements to gain by running these model calculations in Futhark, instead
of in OpenCL and OpenMP.
\\
\\
The goal of this project is to explore the potential speed gains obtained by
rewriting, and testing the resulting speed improvements of, a subset of the
\textit{Sasmodels} models.
The subset will be chosen so that there are at least
one ``simple'' model, one model of intermediate complexity, and one complex
model in it.
\\
\\
If rewriting the models results in a significant\footnote{I.e. a speed increase
  in order of at least a magnitude}, speedup, it will reasonable to believe that 
  the rest of the models in \textit{Sasmodels} can be rewritten for a similar
  speedup.


\section{Demonstration of use of finished project}
As \sasmodels is rarely used on its own, but rather as the backbone of 
\sasview's calculation backend, I am not going to write much about 
\sasview usage.
Instead, I will describe how Futhark models in \sasmodels are leveraged 
by \sasmodels' users.
% mere


\subsection{Describing \sasmodels' models}
A \sasmodels model info file (hereafter referred to as just a model info) is a 
Python file, that defines at least two primary properties of a 
calculation model \textit{m}:
\begin{itemize}

  \item a function definition \texttt{I(q)}, which defines scattered intensity 
  of the scattering vector \texttt{q}.

  \item a list \texttt{parameters}, of the parameters that are used in 
  \texttt{I(q)}. If \texttt{I(q)} does not take any parameters besides 
  \texttt{q}, the list is left empty.
  In the model info file, the parameters are each defined with their unit name, 
  their default values, their value range, their type of parameter and
  a short text describing what they are.
\end{itemize}

Additionally, the model info file also always contains the short-name, 
the full title, a category, and a mathematical \footnote{a representation 
that compiles to a meaningful mathematical expression if used in a LaTeX math 
environment} string representation of the scattering function.

As the scattering function \texttt{I(q)} and its parameters are the only 
two things that are strictly necessary in a model definition, the developer
has the option to leave the model info defined with just these six properties.

\sasmodels has built-in default definitions for $I(q_x,q_y)$ if working
with two-dimensional data, and other functions such as \texttt{form\_volume(q)}
for working with voluminous scatterings.

Therefore, it is optional for the developer to define a custom definition
of $I(q_x, q_y)$ or other default functions.
An example of this can be seen in appendix dab or line.

A minimum viable model is showed in figure \ref{fig:linemodel}, and a more
complex model can be seen in appendix \ref{app:core_shell}

\begin{figure}
  % fuld beskrivelse af ax+b-figur, med parametre a, b, og en Iqxy
  \caption{model info file for modelling a line}\label{fig:linemodel}
\end{figure}

\subsection{Defining \iq in Python and OpenCL}
A \sasmodels \iq function can be written in either Python (which will be
executed in a Numpy context at runtime), or it can be written in C, which will
will be inserted into an OpenCL template, so that it can be compiled and 
executed as a kernel in an OpenCL context, preferably on a GPU.

A Python \iq can be seen in figure \ref{fig:linemodel}, whereas both DAB (figure
\ref{fig:dab} and core\_shell(figure \ref{fig:core-shell}) is written in C.
Notice that the main difference between the models lies in the Iq property.
For Python models, \iq is a callable Python function, whilst the C \iq is a
 string which is copy-pasted wholesale into aforementioned OpenCL template.

But with the addition of Futhark models in \sasmodels adds a third way of
using and defining a \sasmodels model.

\subsection{Using a Futhark model}
\label{sec:using-futhark}
There is a difference between defining and using a Futhark model.
The \sasview user who wishes to use a Futhark model in his or her work does 
not need more than the futhark model info file, and a copy of the compiled
Futhark kernel. In fact, the futhark model info file is identical to OpenCL- 
and Python model info files, except for in two properties.
As show in figure \ref{fig:futhark_dab}, there has been added a flag 
%CHECK THISSS!!!
\texttt{model\_is\_futhark: true}, and \iq is now a path to a precompiled 
Futhark kernel.

The user does not need to have any Futhark compiler installed if he merely wants
to use the precompiled Futhark module: Futhark models for \sasmodels compiles to
portable Python libraries which has numpy and pyopencl as their only 
dependencies - and as \sasmodels has these dependencies as well, the user will
already have these dependencies sorted out, if he has a working installation of 
\sasview or \sasmodels.

\subsection{Defining a Futhark model}
\label{sec:defining-futhark-model}
To have a usable Futhark kernel to run in \sasmodels, it is first necessary to
define it as a Futhark program and compile it using \texttt{futhark-pyopencl}.
A model \textit{m} itself is defined as a parametric Futhark module\footnote{
  A more in-depth explanation of the complete definition of a Futhark module is 
  in \ref{sec:generating-futhark}},
which contains an Iq-function, an Iqxy- and a form\_volume function.
It is the model programmers responsibility to fill in all three functions.

%% figure

A simple example of a Futhark model is the line module, 
as depicted in figure \ref{fig:linemodel-futhark}.
Note that Iqxy is non-default, whilst form\_volume is the default 
implementation.


\subsubsection{On the user friendliness of Futhark models}
As shown in figure \ref{fig:linemodel-futhark}, there are currently two small 
nuisances in Futhark models, compared to equivalent models written in
Python/OpenCL:

With both Python and OpenCL models, the programmer can leave out Iqxy and 
form\_volume so that \sasmodels automatically fills in the default definition
for these two functions instead.

The Futhark programmer does not have this leisure yet, and must define the two
functions no matter what. This is admittedly a piece of annoying boiler plate,
but it is also a thing that can be solved by compartmentalising the offending
functions away in a parametric library module.

The less removable nuisance is that the programmer must explicitly extract the
Iq function parameters from the list \texttt{local\_values}. This must be done
in the order they appear in the model info parameter list.

Iq functions in Python and OpenCL can be defined with any number of function 
parameters, but in Futhark, we need to adhere to the type declaration of Iq 
(see \ref{has-iq}), which means that Iq can take only two arguments; the 
scattering vector \texttt{q}, and the list \texttt{local\_values} of parameters
needed for the scattering.

This makes for an ugly prelude to the actual body of the Iq function, as shown
in fig\ref{fig:linemodel-futhark}, or more critically in models like 
core-shell \ref{fig:core-shell}.


\subsection{Generating Futhark models using parametric modules and a header}
\label{sec:generating-futhark}
As mentioned in \ref{sec:defining-futhark-model}, the futhark model developer
does only need to define three functions to be able to compile a working 
\sasmodels Futhark model.
However, those three functions are merely used by a parametric Futhark module 
\texttt{for\_iq}, which takes care of the actual execution of the 
Futhark kernel.
Let's go through the actual implementation of the Futhark models.

\subsubsection{line\_futhark.fut (a Futhark model)}
\label{sec:line-fut}
\begin{figure}
  % hele line_futhark.fut
  \caption{The complete definition of the line model implemented in Futhark.}
  \label{fig:line-fut}
\end{figure}
There a several things happening in this fig. \ref{fig:line-fut}, besides the 
definition of the line Iq function.

\texttt{module line} takes either single- or double precision floats as a
parameter, and then assigns the type alias \texttt{dtype} to the type of the
input parameter. This means that we can use \texttt{dtype} in the type
declarations throughout the module, and define the module for floats in general,
instead of maybe having to define linef64- and linef32 modules.

Then, two kernels (one for each of f32 and f64) are initialised by giving
the parametric module \texttt{for\_iq} the line module and a data type 
as parameters, returning \texttt{kernel\_float32} and \texttt{kernel\_float64}.

Given these two modules, we can finally define four entry points into the
finished model. These are the four entry points that can be called by \sasmodels
whenever a \sasmodels experiment needs to execute calculations in a futhark
kernel.
Each of the entry points are simply passing on their call parameters to the 
\texttt{run\_kernel} functions defined in the \texttt{for\_iq} module.
Everything after the module line definition is boilerplate code, and could
possibly defined in a less inelegant way in a later revision, but currently, it 
is a necessary part of every Futhark model.

Other models, such as core-shell %FIX\
imports libraries so they are available in the Iq function.
%% som vist i core shell, kan det også være nødvendigt at definere og importere 
% ekstra biblioteker

\subsubsection{header/for\_iq.fut (the Futhark kernel template)}
\texttt{for\_iq.fut} contains the module type declaration for the \hasiq module,
 and it contains the definition of the parametric \foriq module. 

The type declaration \hasiq ensures, that any model module that is
used as a parameter for the \foriq module defines at least the functions
Iq, Iqxy and form\_volume, as these functions are necessary for the definition
of the Futhark kernel.

Next, we have the actual definition of the module \foriq:
\foriq takes two parameters (a parametric Futhark model), and a real type 
to instantiate it with.
It then instantiates the model with the real type, making the finished Iq module
\texttt{Iq} available throughout the rest of the kernel.




\begin{figure}
  % hele for_iq.fut
  % forklar module type
  % forklar module 
  \caption{The Futhark template that is used by the individual models.}
  \label{fig:for-iq}
\end{figure}

\subsubsection{Why not implement Futhark models as model info strings 
instead of standalone modules?}
OpenCL kernels are generated by copy/pasting the desired \iq function body
into a template, and then compiling the resulting source code.
This happens at runtime in \sasmodels, which means that the kernels aren't
 actually compiled until right before \sasmodels needs them.

Futhark models eschews this design and opts instead to separate code generation
and model usage completely.
It would be simple to copy the design of the OpenCL kernels, and compile Futhark
kernels on \sasmodels runtime, but this design was cast aside in favour of the
design described in sec \ref{sec:generating-futhark}.

There are three reasons for that:
\begin{enumerate}
  \item Removing code generation from runtime unequivocally decreases the time
  it takes to run a \sasmodels calculation. Although time taken by code 
  generation is not covered by \sasmodels' built-in benchmark modules, it should
  be obvious that a program that merely executes a kernel computation has a 
  shorter runtime than a program that has to compile the kernel before it
  executes the kernel computation.
  
  \item Compiling a kernel just in time brings the risk of encountering 
  Futhark compilation errors at \sasmodels runtime. 
  It is arguably a user experience nightmare to encounter compilation errors at 
  runtime, which is why Futhark models keeps compilation separate from runtime.
  
  \item Compiling Futhark models down to self-contained\footnote{depending only 
  on numpy and pyopencl} Python libraries means that Futhark models are 
  completely portable, and as such can be used by any \sasmodels or \sasview 
  user, without them needing to have a Futhark compiler installed on their 
  workstations.
\end{enumerate}

\section{Implementation}
% current architecture of Sasmodels engine
% description of kernelcl kernels
% (smaller) description of kernelcl kernels
% description of current kernelfut implementation

\section{Performance tests}

% description of built-in sasmodels comparison functionality
%% description of how comparison module has dictated the design of the futhark kernel (i.e. loading as much data as possible on init)

% display results

% discussion of futhark vs. python performance
%% where does the performance gains come from?

% discussion of futhark vs. opencl performance
%% where does the performance gains come from?
% show core_shell-whatever; and elaborate on loop flattening into maps
%%% MASSER AF REFERENCER TIL TROELS' PAPERS

% correctness

\section{Discussion, future work}
% is this immediately useful? not on single fire runs with low nq
% can be used for data streams / bundling
% experience gains can lay groundwork for parallelising finding best match

% user directed: ease of use,
% (evt.) skønhedsfejl


\section{Conclusion}
% nævn at projektet er blevet præsenteret for en faktisk brugergruppe,
% og fik god og konstruktiv feedback
% det inspirerede til yderligere projekter/forbedringer indenfor sasmodels


\section*{Appendices}

\subsection*{DAB model}

\subsection*{broad_peak model}
\begin{figure}
  \begin[language=Python]{lstlisting}
r"""
Definition
----------
This model calculates an empirical functional form for SAS data characterized
by a broad scattering peak. Many SAS spectra are characterized by a broad peak
even though they are from amorphous soft materials. For example, soft systems
that show a SAS peak include copolymers, polyelectrolytes, multiphase systems,
layered structures, etc.
The d-spacing corresponding to the broad peak is a characteristic distance
between the scattering inhomogeneities (such as in lamellar, cylindrical, or
spherical morphologies, or for bicontinuous structures).
The scattering intensity $I(q)$ is calculated as
.. math:: I(q) = \frac{A}{q^n} + \frac{C}{1 + (|q - q_0|\xi)^m} + B
Here the peak position is related to the d-spacing as $q_0 = 2\pi / d_0$.
$A$ is the Porod law scale factor, $n$ the Porod exponent, $C$ is the
Lorentzian scale factor, $m$ the exponent of $q$, $\xi$ the screening length,
and $B$ the flat background.
For 2D data the scattering intensity is calculated in the same way as 1D,
where the $q$ vector is defined as
.. math:: q = \sqrt{q_x^2 + q_y^2}
References
----------
None.
Authorship and Verification
----------------------------
* **Author:** NIST IGOR/DANSE **Date:** pre 2010
* **Last Modified by:** Paul kienle **Date:** July 24, 2016
* **Last Reviewed by:** Richard Heenan **Date:** March 21, 2016
"""

from numpy import inf, errstate

name = "broad_peak"
title = "Broad Lorentzian type peak on top of a power law decay"
description = """\
      I(q) = scale_p/pow(q,exponent)+scale_l/
      (1.0 + pow((fabs(q-q_peak)*length_l),exponent_l) )+ background
      List of default parameters:
      porod_scale = Porod term scaling
      porod_exp = Porod exponent
      lorentz_scale = Lorentzian term scaling
      lorentz_length = Lorentzian screening length [A]
      peak_pos = peak location [1/A]
      lorentz_exp = Lorentzian exponent
      background = Incoherent background"""
category = "shape-independent"

# pylint: disable=bad-whitespace, line-too-long
#             ["name", "units", default, [lower, upper], "type", "description"],
parameters = [["porod_scale",    "",  1.0e-05, [-inf, inf], "", "Power law scale factor"],
              ["porod_exp",      "",      3.0, [-inf, inf], "", "Exponent of power law"],
              ["lorentz_scale",  "",     10.0, [-inf, inf], "", "Scale factor for broad Lorentzian peak"],
              ["lorentz_length", "Ang",  50.0, [-inf, inf], "", "Lorentzian screening length"],
              ["peak_pos",       "1/Ang", 0.1, [-inf, inf], "", "Peak position in q"],
              ["lorentz_exp",    "",      2.0, [-inf, inf], "", "Exponent of Lorentz function"],
             ]
# pylint: enable=bad-whitespace, line-too-long

def Iq(q,
       porod_scale=1.0e-5,
       porod_exp=3.0,
       lorentz_scale=10.0,
       lorentz_length=50.0,
       peak_pos=0.1,
       lorentz_exp=2.0):
    """
    :param q:              Input q-value
    :param porod_scale:    Power law scale factor
    :param porod_exp:      Exponent of power law
    :param lorentz_scale:  Scale factor for broad Lorentzian peak
    :param lorentz_length: Lorentzian screening length
    :param peak_pos:       Peak position in q
    :param lorentz_exp:    Exponent of Lorentz function
    :return:               Calculated intensity
    """
    z = abs(q - peak_pos) * lorentz_length
    with errstate(divide='ignore'):
        inten = (porod_scale / q ** porod_exp
                 + lorentz_scale / (1 + z ** lorentz_exp))
    return inten
Iq.vectorized = True  # Iq accepts an array of q values

def random():
    import numpy as np
    pars = dict(
        scale=1,
        porod_scale=10**np.random.uniform(-8, -5),
        porod_exp=np.random.uniform(1, 6),
        lorentz_scale=10**np.random.uniform(0.3, 6),
        lorentz_length=10**np.random.uniform(0, 2),
        peak_pos=10**np.random.uniform(-3, -1),
        lorentz_exp=np.random.uniform(1, 4),
    )
    pars['lorentz_length'] /= pars['peak_pos']
    pars['lorentz_scale'] *= pars['porod_scale'] / pars['peak_pos']**pars['porod_exp']
    #pars['porod_scale'] = 0.
    return pars

demo = dict(scale=1, background=0,
            porod_scale=1.0e-05, porod_exp=3,
            lorentz_scale=10, lorentz_length=50, peak_pos=0.1, lorentz_exp=2)
    
  \end{lstlisting}
  \caption{The broad_peak model}
  
\end{figure}


\end{document}
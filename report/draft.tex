\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics

%% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
%% `natbio-farve` to use SCIENCE's new colors and logo.
\def \ColourPDF {include/ku-farve}

%% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
\def \TitlePDF   {include/ku-en}  % University of Copenhagen

\title{
  \vspace{3cm}
  \Huge{Optimizing SasView models} \\
  \Large{Enhancing performance by rewriting kernels from OpenCL/OpenMP to Futhark}
}

\author{
  \Large{Mikkel Storgaard Knudsen}
  \\ \texttt{mikkelstorgaard@gmail.com} \\
  \\
  \Large{Supervisor}
  \\ Martin Elsman
  \\ \texttt{mael@di.ku.dk} \\
}

\date{
    \today
}

\newcommand{\sasmodels}{\textit{SasModels}}
\newcommand{\sasview}{\textit{SasView}}
\newcommand{\iq}{\textit{I(q)}}
\begin{document}


\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]{\ColourPDF}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]{\ColourPDF}}}

\AddToShipoutPicture*{\put(0,0){\includegraphics*{\TitlePDF}}}

\clearpage\maketitle
\thispagestyle{empty}

\section*{Abstract}

\newpage

\section{Introduction}
\subsection{Goal and motivation}
\textit{SasView} is a Small Angle Scattering (SAS) analysis package for the analysis of
1D and 2D scattering data directly in inverse space.
As \textit{SasView} is given data, it performs its analyses by running the input data
through theory models provided by the standalone module \textit{Sasmodels}.
\\
\\
The \textit{Sasmodels} models utilizes a set of kernels, which are implemented
in both OpenCL and OpenMP.
However, benchmark
comparisons\footnote{https://futhark-lang.org/performance.html} between the
parallel algorithm library \textit{Thrust} (implemented in C++/CUDA), and the
array programming language Futhark, shows that there might severe speed
improvements to gain by running these model calculations in Futhark, instead
of in OpenCL and OpenMP.
\\
\\
The goal of this project is to explore the potential speed gains obtained by
rewriting, and testing the resulting speed improvements of, a subset of the
\textit{Sasmodels} models.
The subset will be chosen so that there are at least
one ``simple'' model, one model of intermediate complexity, and one complex
model in it.
\\
\\
If rewriting the models results in a significant\footnote{I.e. a speed increase
  in order of at least a magnitude}, speedup, it will reasonable to believe that 
  the rest of the models in \textit{Sasmodels} can be rewritten for a similar
  speedup.


\section{Demonstration of use of finished project}
As \sasmodels is rarely used on its own, but rather as the backbone of 
\sasview's calculation backend, I am not going to write much about 
\sasview usage.
Instead, I will describe how Futhark models in \sasmodels are leveraged 
by \sasmodels' users.
% mere


\subsection{Describing \sasmodels' models}
A \sasmodels model info file (hereafter referred to as just a model info) is a 
Python file, that defines at least two primary properties of a 
calculation model \textit{m}:
\begin{itemize}

  \item a function definition \texttt{I(q)}, which defines scattered intensity 
  of the scattering vector \texttt{q}.

  \item a list \texttt{parameters}, of the parameters that are used in 
  \texttt{I(q)}. If \texttt{I(q)} does not take any parameters besides 
  \texttt{q}, the list is left empty.
  In the model info file, the parameters are each defined with their unit name, 
  their default values, their value range, their type of parameter and
  a short text describing what they are.
\end{itemize}

Additionally, the model info file also always contains the short-name, 
the full title, a category, and a mathematical \footnote{a representation 
that compiles to a meaningful mathematical expression if used in a LaTeX math 
environment} string representation of the scattering function.

As the scattering function \texttt{I(q)} and its parameters are the only 
two things that are strictly necessary in a model definition, the developer
has the option to leave the model info defined with just these six properties.

\sasmodels has built-in default definitions for \texttt{I(q_x,q_y)} if working
with two-dimensional data, and other functions such as \texttt{form_volume(q)}
for working with voluminous scatterings.

Therefore, it is optional for the developer to define a custom definition
of \texttt{I(q_x, q_y)} or other default functions.
An example of this can be seen in appendix dab or line.

A minimum viable model is showed in figure \ref{fig:linemodel}, and a more
complex model can be seen in appendix \ref{app:core_shell}

\begin{figure}
  % fuld beskrivelse af ax+b-figur, med parametre a, b, og en Iqxy
  \caption{model for modelling a line}\label{fig:linemodel}
\end{figure}

\subsection{Defining \texttt{I(q)} in Python and OpenCL}
A \sasmodels \iq function can be written in either Python (which will be
executed in a Numpy context at runtime), or it can be written in C, which will
will be inserted into an OpenCL template, so that it can be compiled and 
executed as a kernel in an OpenCL context, preferably on a GPU.

A Python \iq can be seen in figure \ref{fig:linemodel}, whereas both DAB (figure
\ref{fig:dab} and core_shell(figure \ref{fig:core_shell}) is written in C.

But with the arrival of Futhark models in \sasmodels, there is now a third
additional way of writing \sasmodels models.














\subsection{Using }

% definition af gammel sasmodels-model
% evt. kald af model.



% til vægs


\section{Ease of use for almene brugere}
% forskel på at skrive moduler, og bare at hente et oversat modul ned

\section{Implementation}
% current architecture of Sasmodels engine
% description of kernelcl kernels
% (smaller) description of kernelcl kernels
% description of current kernelfut implementation
% designovervejelser, hvorfor selvstændige moduler, hvorfor ikke bare udvide kernelpy
%% hvorfor ikke bare definere futhark-Iq-funktionen som string i model.py?
% fordi der ikke er noget kodegnererering ved runtime/ingen futhark-compile-fejl
% under runtime, og prægenererede moduler kan deles med andre, uden disse
% ``andre''' behøver have futhark-oversætteren selv.

\section{Performance tests}

% description of built-in sasmodels comparison functionality
%% description of how comparison module has dictated the design of the futhark kernel (i.e. loading as much data as possible on init)

% display results

% discussion of futhark vs. python performance
%% where does the performance gains come from?

% discussion of futhark vs. opencl performance
%% where does the performance gains come from?
%%% MASSER AF REFERENCER TIL TROELS' PAPERS

% correctness

\section{Discussion, future work}
% is this immediately useful? not on single fire runs with low nq
% can be used for data streams / bundling
% experience gains can lay groundwork for parallelising finding best match

% user directed: ease of use,
% (evt.) skønhedsfejl


\section{Conclusion}
% nævn at projektet er blevet præsenteret for en faktisk brugergruppe,
% og fik god og konstruktiv feedback
% det inspirerede til yderligere projekter/forbedringer indenfor sasmodels


\section*{Appendices}

\subsection*{DAB model}

\subsection*{broad_peak model}
\begin{figure}
  \begin[language=Python]{lstlisting}
r"""
Definition
----------
This model calculates an empirical functional form for SAS data characterized
by a broad scattering peak. Many SAS spectra are characterized by a broad peak
even though they are from amorphous soft materials. For example, soft systems
that show a SAS peak include copolymers, polyelectrolytes, multiphase systems,
layered structures, etc.
The d-spacing corresponding to the broad peak is a characteristic distance
between the scattering inhomogeneities (such as in lamellar, cylindrical, or
spherical morphologies, or for bicontinuous structures).
The scattering intensity $I(q)$ is calculated as
.. math:: I(q) = \frac{A}{q^n} + \frac{C}{1 + (|q - q_0|\xi)^m} + B
Here the peak position is related to the d-spacing as $q_0 = 2\pi / d_0$.
$A$ is the Porod law scale factor, $n$ the Porod exponent, $C$ is the
Lorentzian scale factor, $m$ the exponent of $q$, $\xi$ the screening length,
and $B$ the flat background.
For 2D data the scattering intensity is calculated in the same way as 1D,
where the $q$ vector is defined as
.. math:: q = \sqrt{q_x^2 + q_y^2}
References
----------
None.
Authorship and Verification
----------------------------
* **Author:** NIST IGOR/DANSE **Date:** pre 2010
* **Last Modified by:** Paul kienle **Date:** July 24, 2016
* **Last Reviewed by:** Richard Heenan **Date:** March 21, 2016
"""

from numpy import inf, errstate

name = "broad_peak"
title = "Broad Lorentzian type peak on top of a power law decay"
description = """\
      I(q) = scale_p/pow(q,exponent)+scale_l/
      (1.0 + pow((fabs(q-q_peak)*length_l),exponent_l) )+ background
      List of default parameters:
      porod_scale = Porod term scaling
      porod_exp = Porod exponent
      lorentz_scale = Lorentzian term scaling
      lorentz_length = Lorentzian screening length [A]
      peak_pos = peak location [1/A]
      lorentz_exp = Lorentzian exponent
      background = Incoherent background"""
category = "shape-independent"

# pylint: disable=bad-whitespace, line-too-long
#             ["name", "units", default, [lower, upper], "type", "description"],
parameters = [["porod_scale",    "",  1.0e-05, [-inf, inf], "", "Power law scale factor"],
              ["porod_exp",      "",      3.0, [-inf, inf], "", "Exponent of power law"],
              ["lorentz_scale",  "",     10.0, [-inf, inf], "", "Scale factor for broad Lorentzian peak"],
              ["lorentz_length", "Ang",  50.0, [-inf, inf], "", "Lorentzian screening length"],
              ["peak_pos",       "1/Ang", 0.1, [-inf, inf], "", "Peak position in q"],
              ["lorentz_exp",    "",      2.0, [-inf, inf], "", "Exponent of Lorentz function"],
             ]
# pylint: enable=bad-whitespace, line-too-long

def Iq(q,
       porod_scale=1.0e-5,
       porod_exp=3.0,
       lorentz_scale=10.0,
       lorentz_length=50.0,
       peak_pos=0.1,
       lorentz_exp=2.0):
    """
    :param q:              Input q-value
    :param porod_scale:    Power law scale factor
    :param porod_exp:      Exponent of power law
    :param lorentz_scale:  Scale factor for broad Lorentzian peak
    :param lorentz_length: Lorentzian screening length
    :param peak_pos:       Peak position in q
    :param lorentz_exp:    Exponent of Lorentz function
    :return:               Calculated intensity
    """
    z = abs(q - peak_pos) * lorentz_length
    with errstate(divide='ignore'):
        inten = (porod_scale / q ** porod_exp
                 + lorentz_scale / (1 + z ** lorentz_exp))
    return inten
Iq.vectorized = True  # Iq accepts an array of q values

def random():
    import numpy as np
    pars = dict(
        scale=1,
        porod_scale=10**np.random.uniform(-8, -5),
        porod_exp=np.random.uniform(1, 6),
        lorentz_scale=10**np.random.uniform(0.3, 6),
        lorentz_length=10**np.random.uniform(0, 2),
        peak_pos=10**np.random.uniform(-3, -1),
        lorentz_exp=np.random.uniform(1, 4),
    )
    pars['lorentz_length'] /= pars['peak_pos']
    pars['lorentz_scale'] *= pars['porod_scale'] / pars['peak_pos']**pars['porod_exp']
    #pars['porod_scale'] = 0.
    return pars

demo = dict(scale=1, background=0,
            porod_scale=1.0e-05, porod_exp=3,
            lorentz_scale=10, lorentz_length=50, peak_pos=0.1, lorentz_exp=2)
    
  \end{lstlisting}
  \caption{The broad_peak model}
  
\end{figure}


\end{document}
\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics

%% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
%% `natbio-farve` to use SCIENCE's new colors and logo.
\def \ColourPDF {include/ku-farve}

%% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
\def \TitlePDF   {include/ku-en}  % University of Copenhagen

\title{
  \vspace{3cm}
  \Huge{Optimizing SasView models} \\
  \Large{Enhancing performance by rewriting kernels from OpenCL/OpenMP to Futhark}
}

\author{
  \Large{Mikkel Storgaard Knudsen}
  \\ \texttt{mikkelstorgaard@gmail.com} \\
  \\
  \Large{Supervisor}
  \\ Martin Elsman
  \\ \texttt{mael@di.ku.dk} \\
}

\date{
    \today
}

\newcommand{\sasmodels}{\textit{SasModels}}
\newcommand{\sasview}{\textit{SasView}}
\newcommand{\iq}{\textit{I(q)}}
\begin{document}


\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]{\ColourPDF}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]{\ColourPDF}}}

\AddToShipoutPicture*{\put(0,0){\includegraphics*{\TitlePDF}}}

\clearpage\maketitle
\thispagestyle{empty}

\section*{Abstract}

\newpage

\section{Introduction}
\subsection{Goal and motivation}
\textit{SasView} is a Small Angle Scattering (SAS) analysis package for the analysis of
1D and 2D scattering data directly in inverse space.
As \textit{SasView} is given data, it performs its analyses by running the input data
through theory models provided by the standalone module \textit{Sasmodels}.
\\
\\
The \textit{Sasmodels} models utilizes a set of kernels, which are implemented
in both OpenCL and OpenMP.
However, benchmark
comparisons\footnote{https://futhark-lang.org/performance.html} between the
parallel algorithm library \textit{Thrust} (implemented in C++/CUDA), and the
array programming language Futhark, shows that there might severe speed
improvements to gain by running these model calculations in Futhark, instead
of in OpenCL and OpenMP.
\\
\\
The goal of this project is to explore the potential speed gains obtained by
rewriting, and testing the resulting speed improvements of, a subset of the
\textit{Sasmodels} models.
The subset will be chosen so that there are at least
one ``simple'' model, one model of intermediate complexity, and one complex
model in it.
\\
\\
If rewriting the models results in a significant\footnote{I.e. a speed increase
  in order of at least a magnitude}, speedup, it will reasonable to believe that 
  the rest of the models in \textit{Sasmodels} can be rewritten for a similar
  speedup.


\section{Demonstration of use of finished project}
As \sasmodels is rarely used on its own, but rather as the backbone of 
\sasview's calculation backend, I am not going to write much about 
\sasview usage.
Instead, I will describe how Futhark models in \sasmodels are leveraged 
by \sasmodels' users.
% mere


\subsection{Describing \sasmodels' models}
A \sasmodels model info file (hereafter referred to as just a model info) is a 
Python file, that defines at least two primary properties of a 
calculation model \textit{m}:
\begin{itemize}

  \item a function definition \texttt{I(q)}, which defines scattered intensity 
  of the scattering vector \texttt{q}.

  \item a list \texttt{parameters}, of the parameters that are used in 
  \texttt{I(q)}. If \texttt{I(q)} does not take any parameters besides 
  \texttt{q}, the list is left empty.
  In the model info file, the parameters are each defined with their unit name, 
  their default values, their value range, their type of parameter and
  a short text describing what they are.
\end{itemize}

Additionally, the model info file also always contains the short-name, 
the full title, a category, and a mathematical \footnote{a representation 
that compiles to a meaningful mathematical expression if used in a LaTeX math 
environment} string representation of the scattering function.

As the scattering function \texttt{I(q)} and its parameters are the only 
two things that are strictly necessary in a model definition, the developer
has the option to leave the model info defined with just these six properties.

\sasmodels has built-in default definitions for $I(q_x,q_y)$ if working
with two-dimensional data, and other functions such as \texttt{form\_volume(q)}
for working with voluminous scatterings.

Therefore, it is optional for the developer to define a custom definition
of $I(q_x, q_y)$ or other default functions.
An example of this can be seen in appendix dab or line.

A minimum viable model is showed in figure \ref{fig:linemodel}, and a more
complex model can be seen in appendix \ref{app:core_shell}

\begin{figure}
  % fuld beskrivelse af ax+b-figur, med parametre a, b, og en Iqxy
  \caption{model info file for modelling a line}\label{fig:linemodel}
\end{figure}

\subsection{Defining \iq in Python and OpenCL}
A \sasmodels \iq function can be written in either Python (which will be
executed in a Numpy context at runtime), or it can be written in C, which will
will be inserted into an OpenCL template, so that it can be compiled and 
executed as a kernel in an OpenCL context, preferably on a GPU.

A Python \iq can be seen in figure \ref{fig:linemodel}, whereas both DAB (figure
\ref{fig:dab} and core\_shell(figure \ref{fig:core-shell}) is written in C.
Notice that the main difference between the models lies in the Iq property.
For Python models, \iq is a callable Python function, whilst the C \iq is a
 string which is copy-pasted wholesale into aforementioned OpenCL template.

But with the addition of Futhark models in \sasmodels adds a third way of
using and defining a \sasmodels model.

\subsection{Using a Futhark model}
\label{sec:using-futhark}
There is a difference between defining and using a Futhark model.
The \sasview user who wishes to use a Futhark model in his or her work does 
not need more than the futhark model info file, and a copy of the compiled
Futhark kernel. In fact, the futhark model info file is identical to OpenCL- 
and Python model info files, except for in two properties.
As show in figure \ref{fig:futhark_dab}, there has been added a flag 
%CHECK THISSS!!!
\texttt{model\_is\_futhark: true}, and \iq is now a path to a precompiled 
Futhark kernel.

The user does not need to have any Futhark compiler installed if he merely wants
to use the precompiled Futhark module: Futhark models for \sasmodels compiles to
portable Python libraries which has numpy and pyopencl as their only 
dependencies - and as \sasmodels has these dependencies as well, the user will
already have these dependencies sorted out, if he has a working installation of 
\sasview or \sasmodels.

\subsection{Defining a Futhark model}
To have a usable Futhark kernel to run in \sasmodels, it is first necessary to
define it as a Futhark program and compile it using \texttt{futhark-pyopencl}.
A model \textit{m} itself is defined as a parametric Futhark module\footnote{
  A more in-depth explanation of the complete definition of a Futhark module is 
  in \ref{sec:generating-futhark}},
which contains an Iq-function, an Iqxy- and a form\_volume function.
It is the model programmers responsibility to fill in all three functions.

%% figure

A simple example of a Futhark model is the line module, 
as depicted in figure \ref{fig:linemodel-futhark}.
Note that Iqxy is non-default, whilst form\_volume is the default 
implementation.


\subsubsection{On the user friendliness of Futhark models}
As shown in figure \ref{fig:linemodel-futhark}, there are currently two small 
nuisances in Futhark models, compared to equivalent models written in
Python/OpenCL:

With both Python and OpenCL models, the programmer can leave out Iqxy and 
form\_volume so that \sasmodels automatically fills in the default definition
for these two functions instead.

The Futhark programmer does not have this leisure yet, and must define the two
functions no matter what. This is admittedly a piece of annoying boiler plate,
but it is also a thing that can be solved by compartmentalising the offending
functions away in a parametric library module.

The less removable nuisance is that the programmer must explicitly extract the
Iq function parameters from the list \texttt{local\_values}. This must be done
in the order they appear in the model info parameter list.

Iq functions in Python and OpenCL can be defined with any number of function 
parameters, but in Futhark, we need to adhere to the type declaration of Iq 
(see \ref{has-iq}), which means that Iq can take only two arguments; the 
scattering vector \texttt{q}, and the list \texttt{local\_values} of parameters
needed for the scattering.

This makes for an ugly prelude to the actual body of the Iq function, as shown
in fig\ref{fig:linemodel-futhark}, or more critically in models like 
core-shell \ref{fig:core-shell}.


\subsection{Generating Futhark models using parametric modules and a header}
\label{sec:generating-futhark}
\begin{lstlisting}
module type has_iq = {
Iq: real -> real[] -> real // the model's scattering function.
Iqxy: real -> real -> real[] -> real // the model's 2D scattering function
form_volume: real[] -> real // the model's form volume function.
}  
\end{lstlisting}

% definition af gammel sasmodels-model
% evt. kald af model.


% til vægs

\subsubsection{Why not Futhark models as model info strings instead standalone modules?}
% designovervejelser, hvorfor selvstændige moduler, hvorfor ikke bare udvide kernelpy
%% hvorfor ikke bare definere futhark-Iq-funktionen som string i model.py?
% fordi der ikke er noget kodegnererering ved runtime/ingen futhark-compile-fejl
% under runtime, og prægenererede moduler kan deles med andre, uden disse
% ``andre''' behøver have futhark-oversætteren selv.


\section{Ease of use for almene brugere}
% forskel på at skrive moduler, og bare at hente et oversat modul ned

\section{Implementation}
% current architecture of Sasmodels engine
% description of kernelcl kernels
% (smaller) description of kernelcl kernels
% description of current kernelfut implementation

\section{Performance tests}

% description of built-in sasmodels comparison functionality
%% description of how comparison module has dictated the design of the futhark kernel (i.e. loading as much data as possible on init)

% display results

% discussion of futhark vs. python performance
%% where does the performance gains come from?

% discussion of futhark vs. opencl performance
%% where does the performance gains come from?
% show core_shell-whatever; and elaborate on loop flattening into maps
%%% MASSER AF REFERENCER TIL TROELS' PAPERS

% correctness

\section{Discussion, future work}
% is this immediately useful? not on single fire runs with low nq
% can be used for data streams / bundling
% experience gains can lay groundwork for parallelising finding best match

% user directed: ease of use,
% (evt.) skønhedsfejl


\section{Conclusion}
% nævn at projektet er blevet præsenteret for en faktisk brugergruppe,
% og fik god og konstruktiv feedback
% det inspirerede til yderligere projekter/forbedringer indenfor sasmodels


\section*{Appendices}

\subsection*{DAB model}

\subsection*{broad_peak model}
\begin{figure}
  \begin[language=Python]{lstlisting}
r"""
Definition
----------
This model calculates an empirical functional form for SAS data characterized
by a broad scattering peak. Many SAS spectra are characterized by a broad peak
even though they are from amorphous soft materials. For example, soft systems
that show a SAS peak include copolymers, polyelectrolytes, multiphase systems,
layered structures, etc.
The d-spacing corresponding to the broad peak is a characteristic distance
between the scattering inhomogeneities (such as in lamellar, cylindrical, or
spherical morphologies, or for bicontinuous structures).
The scattering intensity $I(q)$ is calculated as
.. math:: I(q) = \frac{A}{q^n} + \frac{C}{1 + (|q - q_0|\xi)^m} + B
Here the peak position is related to the d-spacing as $q_0 = 2\pi / d_0$.
$A$ is the Porod law scale factor, $n$ the Porod exponent, $C$ is the
Lorentzian scale factor, $m$ the exponent of $q$, $\xi$ the screening length,
and $B$ the flat background.
For 2D data the scattering intensity is calculated in the same way as 1D,
where the $q$ vector is defined as
.. math:: q = \sqrt{q_x^2 + q_y^2}
References
----------
None.
Authorship and Verification
----------------------------
* **Author:** NIST IGOR/DANSE **Date:** pre 2010
* **Last Modified by:** Paul kienle **Date:** July 24, 2016
* **Last Reviewed by:** Richard Heenan **Date:** March 21, 2016
"""

from numpy import inf, errstate

name = "broad_peak"
title = "Broad Lorentzian type peak on top of a power law decay"
description = """\
      I(q) = scale_p/pow(q,exponent)+scale_l/
      (1.0 + pow((fabs(q-q_peak)*length_l),exponent_l) )+ background
      List of default parameters:
      porod_scale = Porod term scaling
      porod_exp = Porod exponent
      lorentz_scale = Lorentzian term scaling
      lorentz_length = Lorentzian screening length [A]
      peak_pos = peak location [1/A]
      lorentz_exp = Lorentzian exponent
      background = Incoherent background"""
category = "shape-independent"

# pylint: disable=bad-whitespace, line-too-long
#             ["name", "units", default, [lower, upper], "type", "description"],
parameters = [["porod_scale",    "",  1.0e-05, [-inf, inf], "", "Power law scale factor"],
              ["porod_exp",      "",      3.0, [-inf, inf], "", "Exponent of power law"],
              ["lorentz_scale",  "",     10.0, [-inf, inf], "", "Scale factor for broad Lorentzian peak"],
              ["lorentz_length", "Ang",  50.0, [-inf, inf], "", "Lorentzian screening length"],
              ["peak_pos",       "1/Ang", 0.1, [-inf, inf], "", "Peak position in q"],
              ["lorentz_exp",    "",      2.0, [-inf, inf], "", "Exponent of Lorentz function"],
             ]
# pylint: enable=bad-whitespace, line-too-long

def Iq(q,
       porod_scale=1.0e-5,
       porod_exp=3.0,
       lorentz_scale=10.0,
       lorentz_length=50.0,
       peak_pos=0.1,
       lorentz_exp=2.0):
    """
    :param q:              Input q-value
    :param porod_scale:    Power law scale factor
    :param porod_exp:      Exponent of power law
    :param lorentz_scale:  Scale factor for broad Lorentzian peak
    :param lorentz_length: Lorentzian screening length
    :param peak_pos:       Peak position in q
    :param lorentz_exp:    Exponent of Lorentz function
    :return:               Calculated intensity
    """
    z = abs(q - peak_pos) * lorentz_length
    with errstate(divide='ignore'):
        inten = (porod_scale / q ** porod_exp
                 + lorentz_scale / (1 + z ** lorentz_exp))
    return inten
Iq.vectorized = True  # Iq accepts an array of q values

def random():
    import numpy as np
    pars = dict(
        scale=1,
        porod_scale=10**np.random.uniform(-8, -5),
        porod_exp=np.random.uniform(1, 6),
        lorentz_scale=10**np.random.uniform(0.3, 6),
        lorentz_length=10**np.random.uniform(0, 2),
        peak_pos=10**np.random.uniform(-3, -1),
        lorentz_exp=np.random.uniform(1, 4),
    )
    pars['lorentz_length'] /= pars['peak_pos']
    pars['lorentz_scale'] *= pars['porod_scale'] / pars['peak_pos']**pars['porod_exp']
    #pars['porod_scale'] = 0.
    return pars

demo = dict(scale=1, background=0,
            porod_scale=1.0e-05, porod_exp=3,
            lorentz_scale=10, lorentz_length=50, peak_pos=0.1, lorentz_exp=2)
    
  \end{lstlisting}
  \caption{The broad_peak model}
  
\end{figure}


\end{document}
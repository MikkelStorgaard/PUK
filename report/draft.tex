\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics
\usepackage{listings} % \includegraphics
\usepackage{pgfplots}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{mdframed}
\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\lstset{
  basicstyle=\tiny,
  showspaces=false,
  showstringspaces=false,
  columns=flexible,
  breaklines=true,
  numbers=left
}

%% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
%% `natbio-farve` to use SCIENCE's new colors and logo.
\def \ColourPDF {include/ku-farve}

%% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
\def \TitlePDF   {include/ku-en}  % University of Copenhagen

\newcommand{\sasmodels}{\textit{SasModels}}
\newcommand{\sasview}{\textit{SasView}}
\newcommand{\iq}{\textit{I(q)}}
\newcommand{\foriq}{\texttt{for\_iq}}
\newcommand{\hasiq}{\texttt{has\_iq}}
\newcommand{\futhark}{\texttt{Futhark for SasModels}}
\newcommand{\barheight}{5cm}

\title{
  \vspace{3cm}
  \Huge{\futhark}\\
  \Large{Enhancing performance by rewriting kernels from Python/OpenCL to
    Futhark}
}

\author{
  \Large{Mikkel Storgaard Knudsen}\\
  \texttt{mikkelstorgaard@gmail.com}\\
  \\
  \Large{Supervisor}\\
  Martin Elsman\\
  \texttt{mael@di.ku.dk}
}

\date{
    \today
}

\begin{document}


\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]{\ColourPDF}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]{\ColourPDF}}}

\AddToShipoutPicture*{\put(0,0){\includegraphics*{\TitlePDF}}}

\clearpage\maketitle
\thispagestyle{empty}

\section*{Abstract}
This report describes the design and implementation of a Futhark extension for
the modelling engine \sasmodels.
\sasmodels{} performs small angle scattering calculations for the \sasview{}
modelling suite, by sending it's input to a range of calculation models
implemented in Python and OpenCL.\\\\

%%% whaaaat




\newpage

\section{Introduction}
\subsection{Goal and motivation}
\sasview is a Small Angle Scattering (SAS) analysis package for the
analysis of 1D and 2D scattering data directly in inverse space.
As \sasview is given data, it performs its analyses by running the
input data through theory models provided by the standalone module
\sasmodels.

The \sasmodels models utilizes a set of kernels, which are implemented
in both Python and OpenCL. However, benchmark
comparisons\footnote{https://futhark-lang.org/performance.html}
between the parallel algorithm library \textit{Thrust}
(implemented in C++/CUDA), and the array programming language Futhark, shows
that there might severe speed improvements to gain by running these model
calculations in Futhark, instead of in OpenCL as they are now.

The goal of this project is to explore the potential speed gains obtained by
rewriting, and testing the resulting speed improvements of, a subset of the
\sasmodels models.
The subset will be chosen so that there are at least
one ``simple'' model, one model of intermediate complexity, and one complex
model in it.

If rewriting the models results in a significant\footnote{I.e. a speed increase
  in order of at least a magnitude}, speedup, it will reasonable to believe that 
  the rest of the models in \sasmodels can be rewritten for a similar
  speedup.

\section{Demonstration of use of finished project}
As \sasmodels is rarely used on its own, but rather as the backbone of 
\sasview's calculation backend, I am not going to write much about 
\sasview usage.
Instead, I will describe how Futhark models in \sasmodels are leveraged 
by \sasmodels' users.
måske ikke så meget mere her
% mere


\subsection{Describing \sasmodels' models}
A \sasmodels model info file (hereafter referred to as just a model info) is a 
Python file, that defines at least two primary properties of a 
calculation model \textit{m}:
\begin{itemize}

  \item a function definition \texttt{I(q)}, which defines scattered intensity 
  of the scattering vector \texttt{q}.

  \item a list \texttt{parameters}, of the parameters that are used in 
  \texttt{I(q)}. If \texttt{I(q)} does not take any parameters besides 
  \texttt{q}, the list is left empty.
  In the model info file, the parameters are each defined with their unit name, 
  their default values, their value range, their type of parameter and
  a short text describing what they are.
\end{itemize}

Additionally, the model info file also always contains the short-name, 
the full title, a category, and a mathematical \footnote{a representation 
that compiles to a meaningful mathematical expression if used in a LaTeX math 
environment} string representation of the scattering function.

As the scattering function \texttt{I(q)} and its parameters are the only 
two things that are strictly necessary in a model definition, the developer
has the option to leave the model info defined with just these six properties.

\sasmodels{} has built-in default definitions for $I(q_x,q_y)$ if working
with two-dimensional data, and other functions such as \texttt{form\_volume(q)}
for working with voluminous scatterings.

Therefore, it is optional for the developer to define a custom definition
of $I(q_x, q_y)$ or other default functions.
An example of this can be seen in figure \ref{fig:linemodel}.
A more complex model can be seen in appendix \ref{fig:core_shell}

\begin{figure}
  % fuld beskrivelse af ax+b-figur, med parametre a, b, og en Iqxy
  \caption{model info file for modelling a line}\label{fig:linemodel}
\end{figure}

\subsection{Defining \iq in Python and OpenCL}
A \sasmodels \iq function can be written in either Python (which will be
executed in a Numpy context at runtime), or it can be written in C, which will
will be inserted into an OpenCL template, so that it can be compiled and 
executed as a kernel in an OpenCL context, preferably on a GPU.

A Python \iq can be seen in figure \ref{fig:linemodel}, whereas both DAB (figure
\ref{fig:dab} and core\_shell(figure \ref{fig:core-shell}) is written in C.
Notice that the main difference between the models lies in the Iq property.
For Python models, \iq is a callable Python function, whilst the C \iq is a
 string which is copy-pasted wholesale into aforementioned OpenCL template.

But with the addition of Futhark models in \sasmodels adds a third way of
using and defining a \sasmodels model.

\subsection{Using a Futhark model}
\label{sec:using-futhark}
There is a difference between defining and using a Futhark model.
The \sasview user who wishes to use a Futhark model in his or her work does 
not need more than the futhark model info file, and a copy of the compiled
Futhark kernel. In fact, the futhark model info file is identical to OpenCL- 
and Python model info files, except for in two properties.
As show in figure \ref{fig:futhark_dab}, there has been added a flag 
%CHECK THISSS!!!
\texttt{model\_is\_futhark: true}, and \iq is now a path to a precompiled 
Futhark kernel.

The user does not need to have any Futhark compiler installed if he merely wants
to use the precompiled Futhark module: Futhark models for \sasmodels compiles to
portable Python libraries which has numpy and pyopencl as their only 
dependencies - and as \sasmodels has these dependencies as well, the user will
already have these dependencies sorted out, if he has a working installation of 
\sasview or \sasmodels.

\subsection{Defining a Futhark model}
\label{sec:defining-futhark-model}
To have a usable Futhark kernel to run in \sasmodels, it is first necessary to
define it as a Futhark program and compile it using \texttt{futhark-pyopencl}.
A model \textit{m} itself is defined as a parametric Futhark module\footnote{
  A more in-depth explanation of the complete definition of a Futhark module is 
  in \ref{sec:generating-futhark}},
which contains an Iq-function, an Iqxy- and a form\_volume function.
It is the model programmers responsibility to fill in all three functions.

A simple example of a Futhark model is the line module, 
as depicted in figure \ref{fig:linemodel-futhark}.
Note that Iqxy is non-default, whilst form\_volume is the default 
implementation.


\subsubsection{On the user friendliness of Futhark models}
As shown in figure \ref{fig:linemodel-futhark}, there are currently two small 
nuisances in Futhark models, compared to equivalent models written in
Python/OpenCL:

With both Python and OpenCL models, the programmer can leave out Iqxy and 
form\_volume so that \sasmodels automatically fills in the default definition
for these two functions instead.

The Futhark programmer does not have this leisure yet, and must define the two
functions no matter what. This is admittedly a piece of annoying boiler plate,
but it is also a thing that can be solved by compartmentalising the offending
functions away in a parametric library module.

The less removable nuisance is that the programmer must explicitly extract the
Iq function parameters from the list \texttt{local\_values}. This must be done
in the order they appear in the model info parameter list.

Iq functions in Python and OpenCL can be defined with any number of function 
parameters, but in Futhark, we need to adhere to the type declaration of Iq 
(see \ref{has-iq}), which means that Iq can take only two arguments; the 
scattering vector \texttt{q}, and the list \texttt{local\_values} of parameters
needed for the scattering.

This makes for an ugly prelude to the actual body of the Iq function, as shown
in fig\ref{fig:linemodel-futhark}, or more critically in models like 
core-shell \ref{fig:core-shell}.


\subsection{Generating Futhark models using parametric modules and a header}
\label{sec:generating-futhark}
As mentioned in \ref{sec:defining-futhark-model}, the futhark model developer
does only need to define three functions to be able to compile a working 
\sasmodels Futhark model.
However, those three functions are merely used by a parametric Futhark module 
\texttt{for\_iq}, which takes care of the actual execution of the 
Futhark kernel.
Let's go through the actual implementation of the Futhark models.

\subsubsection{line\_futhark.fut (a Futhark model)}
\label{sec:line-fut}

\begin{figure}
  \lstinputlisting[]{../sasmodels/sasmodels/models/futharks/line_futhark.fut}
  \caption{The complete definition of the line model implemented in Futhark.}
  \label{fig:linemodel-futhark-full}
\end{figure}

There a several things happening in this fig. \ref{fig:linemodel-futhark-full}, besides the 
definition of the line Iq function.

\texttt{module line} takes either single- or double precision floats as a
parameter, and then assigns the type alias \texttt{dtype} to the type of the
input parameter. This means that we can use \texttt{dtype} in the type
declarations throughout the module, and define the module for floats in general,
instead of maybe having to define linef64- and linef32 modules.

Then, two kernels (one for each of f32 and f64) are initialised by giving
the parametric module \texttt{for\_iq} the line module and a data type 
as parameters, returning \texttt{kernel\_float32} and \texttt{kernel\_float64}.

Given these two modules, we can finally define four entry points into the
finished model. These are the four entry points that can be called by \sasmodels
whenever a \sasmodels experiment needs to execute calculations in a futhark
kernel.
Each of the entry points are simply passing on their call parameters to the 
\texttt{run\_kernel} functions defined in the \texttt{for\_iq} module.
Everything after the module line definition is boilerplate code, and could
possibly defined in a less inelegant way in a later revision, but currently, it 
is a necessary part of every Futhark model.

Other models, such as core-shell %FIX\
imports libraries so they are available in the Iq function.
%% som vist i core shell, kan det også være nødvendigt at definere og importere 
% ekstra biblioteker

\subsubsection{header/for\_iq.fut (the Futhark kernel template)}
\texttt{for\_iq.fut} contains the module type declaration for the \hasiq module,
 and it contains the definition of the parametric \foriq module. 

The type declaration \hasiq ensures, that any model module that is
used as a parameter for the \foriq module defines at least the functions
Iq, Iqxy and form\_volume, as these functions are necessary for the definition
of the Futhark kernel.

Next, we have the actual definition of the module \foriq:
\foriq takes two parameters (a parametric Futhark model), and a real type 
to instantiate it with.
It then instantiates the model with the real type, making the finished Iq module
\texttt{Iq} available throughout the rest of the kernel.

Then finally, it uses the Iq module to define the two functions 
\texttt{run\_kernel}, and \texttt{run\_kernel\_2d}, which defines the actual 
\sasmodels computation procedure with the scattering functions injected by 
the Iq module.

\begin{figure}
  \lstinputlisting[]{../sasmodels/sasmodels/models/futharks/header/for_iq.fut}
  \caption{The Futhark template that is used by the individual models.}
  \label{fig:for-iq}
\end{figure}

\subsubsection{Why not implement Futhark models as model info strings 
instead of standalone modules?}
OpenCL kernels are generated by copy/pasting the desired \iq function body
into a template, and then compiling the resulting source code.
This happens at runtime in \sasmodels, which means that the kernels aren't
 actually compiled until right before \sasmodels needs them.

Futhark models eschews this design and opts instead to separate code generation
and model usage completely.
It would be simple to copy the design of the OpenCL kernels, and compile Futhark
kernels on \sasmodels runtime, but this design was cast aside in favour of the
design described in sec \ref{sec:generating-futhark}.

There are three reasons for that:
\begin{enumerate}
  \item Removing code generation from runtime unequivocally decreases the time
  it takes to run a \sasmodels calculation. Although time taken by code 
  generation is not covered by \sasmodels' built-in benchmark modules, it should
  be obvious that a program that merely executes a kernel computation has a 
  shorter runtime than a program that has to compile the kernel before it
  executes the kernel computation.
  
  \item Compiling a kernel just in time brings the risk of encountering 
  Futhark compilation errors at \sasmodels runtime. 
  It is arguably a user experience nightmare to encounter compilation errors at 
  runtime, which is why Futhark models keeps compilation separate from runtime.
  
  \item Compiling Futhark models down to self-contained\footnote{depending only 
  on Numpy and Pyopencl} Python libraries means that Futhark models are 
  completely portable, and as such can be used by any \sasmodels or \sasview 
  user, without them needing to have a Futhark compiler installed on their 
  workstations.
\end{enumerate}

\section{Implementation of \texttt{kernelfut.py}}
\sasmodels 

% current architecture of Sasmodels engine
% description of kernelcl kernels
% (smaller) description of kernelcl kernels
% description of current kernelfut implementation

\section{Method}

% description of built-in sasmodels comparison functionality
\sasmodels contains a comparison module called \texttt{compare.py}, which
lets the user run different calculations on the same dataset.
This module has been the basis of all my performance tests, and indeed also
the module that has let me design Futhark models in the first place.

The development of Futhark for \sasmodels has been largely test-driven.
For any given already existing model in the \sasmodels catalogue that I have
wished to implement in Futhark, I have started out by defining an equivalent
model written in Futhark, and then used the comparison module to compare the
 runs of the original model versus the Futhark implementation.

The comparison module displays the average execution time of each of the models,
which lets me track exactly how much faster (or slower) the Futhark model has
been running, compared to the original implementation.

Furthermore, and ultimately most important, the comparison module also
revealed the difference in results between the two models. 
As I have precisely zero knowledge on the field of Small Angle Scatterings, 
the only option for me regarding correctness of the models has been to take
the results of the already existing models as the "correct" results of the
computations. Consequently, any difference between my Futhark results and the
original results has been direct indicators of faulty implementations or bugs
somewhere along my work.
Therefore, I have been developing and debugging my solution by repeatedly
comparing it's results to that of the original implementation.

Conversely, I have chosen to accept test runs with exactly no difference
between the original and the Futhark implementation, as indicators of a
correct implementation. 
Test runs with thousands of data points defined as double-precision
with more than ten decimal points have still resulted in a total difference of
zero\footnote{see \ref{sec:correctness}} between the models.
This is what I base my assertion of a correctness on, as even the smallest 
mistakes along the calculations would surely have resulted in a very significant
accumulated error in the final results.

The test driven development has also lead to some of the biggest performance
optimizations in my design of kernelfut.py.
In example, the initial tests showed that the Futhark kernels were unreasonably
much slower than the already existing kernels. After some investigation I found
that this was because the original implementation buffered the input data in the
OpenCL context long time before the actual kernel was called in Python, whereas
the first versions of the Futhark kernel buffered the input data in the OpenCL
context as part of the \texttt{run\_kernel} function call.

\section{Performance results}
\label{performance}
\subsection{Futhark vs. Python performance}
I have tested Futhark vs. Python performance on two different models; 
the \texttt{line} model and the \texttt{broad\_peak} model.

\subsubsection{\texttt{line} model}
The \iq function for the line model is defined as $I(q) = A + B*q$, which is
equivalent to one of the most basic high school math functions, $f(x) = ax + b$.

\begin{figure}
    \begin{tikzpicture}
      \begin{axis}[
        mbarplot,
        title={1D performance},
        xlabel={number of datapoints},
        ylabel={Time in milliseconds},
        width=0.9\textwidth,
        height=\barheight,
        symbolic x coords={100,500,2500,5000,10000},
        bar width=9pt,
        enlargelimits=0.15,
        ybar=10pt,% configures ‘bar shift’
        bar width=12pt,
        nodes near coords,
        legend style={legend pos=north west}
      ]
      \addplot plot coordinates {(100, 0.24 ) (500, 0.24 ) (2500, 0.26 ) (5000, 0.26 ) (10000, 0.28 )};
      \addplot plot coordinates {(100, 0.93 ) (500, 0.94 ) (2500, 0.97 ) (5000, 0.95 ) (10000, 0.97 )};
      \legend{Current, Futhark}
      \end{axis}
    \end{tikzpicture}
    \begin{tikzpicture}
      \begin{axis}[
        mbarplot,
        title={2D performance},
        xlabel={number of datapoints},
        ylabel={Time in milliseconds},
        width=0.9\textwidth,
        height=\barheight,
        symbolic x coords={100,500,2500,5000,10000},
        bar width=9pt,
        enlargelimits=0.15,
        ybar=10pt,% configures ‘bar shift’
        bar width=12pt,
        nodes near coords,
        legend style={legend pos=north west}
      ]
      \addplot plot coordinates {(100, 0.31 ) (500, 2.78 ) (2500, 127.01 ) (5000, 501.31 ) (10000, 1970.14 )};
      \addplot plot coordinates {(100, 0.98 ) (500, 1.91 ) (2500, 22.73 ) (5000, 86.03 ) (10000, 338.10 )};

      \legend{Current, Futhark}

      \end{axis}
    \end{tikzpicture}
    \label{fig:line-graph}
    \caption{Comparison between Python and Futhark performance for simple model}
\end{figure}

In figure \ref{fig:line-graph} we see that for one dimensional calculations,
both implementations keep a steady execution time. Futhark is consistently 
slower, but that can be explained by the overhead of using the Futhark kernels.

More interesting is it to look at the execution time of the 2D version of the 
experiment. For all \sasmodels 2D experiments, we are not just calculating \iq
for each q, but actually $\sum_{q \in Q} \sum_{q \in Q} Iq(q_x, q_y)$.
So if we have $n$ q, we need to perform $n^2$ calculations.

We see in the figure, that Futhark at 10000^2 datapoints now greatly outperforms
the Python model.

\subsubsection{\texttt{broad\_peak} model}
Broad Peak is quite a different beast than the line model from before. It's \iq
function is defined as 
$I(q) = \frac{A}{q^n} + \frac{C}{1 + (|q - q_0|\xi)^m} + B$.\footnote{see \url{http://www.sasview.org/docs/user/models/broad_peak.html}}

\begin{figure}
      \begin{tikzpicture}
      \begin{axis}[
        mbarplot,
        title={1D performance},
        xlabel={number of datapoints},
        ylabel={Time in milliseconds},
        width=0.9\textwidth,
        height=\barheight,
        symbolic x coords={100,500,2500,5000,10000},
        bar width=9pt,
        enlargelimits=0.15,
        ybar=10pt,% configures ‘bar shift’
        bar width=12pt,
        nodes near coords,
        legend style={legend pos=north west}
      ]
      \addplot plot coordinates {(100,0.27) (500,0.30) (2500,0.45) (5000,0.63) (10000,1.22)};
      \addplot plot coordinates {(100,1.22) (500,1.23) (2500,1.23) (5000,1.25) (10000,1.27)};

      \legend{Current, Futhark}
      \end{axis}
    \end{tikzpicture}
    \begin{tikzpicture}
      \begin{axis}[
        mbarplot,
        title={2D performance},
        xlabel={number of datapoints},
        ylabel={Time in milliseconds},
        width=0.9\textwidth,
        height=\barheight,
        symbolic x coords={100,500,2500,5000,10000},
        bar width=9pt,
        enlargelimits=0.15,
        ybar=10pt,% configures ‘bar shift’
        bar width=12pt,
        nodes near coords,
        legend style={legend pos=north west}
      ]
      \addplot plot coordinates {(100,1.06 ) (500,21.50 ) (2500,675.12) (5000,2686.44 ) (10000,10687)};
      \addplot plot coordinates {(100,1.27 ) (500,2.27 ) (2500,27.48) (5000,103.66 ) (10000,409)};

      \legend{Current, Futhark}

      \end{axis}
    \end{tikzpicture}
    \label{fig:broad-peak-graph}
    \caption{Comparison between Python and Futhark performance for complex model}
\end{figure}

In figure \ref{fig:line-graph} we see that for one dimensional calculations,
both implementations keep a steady execution time. Futhark is consistently 
slower, but that can be explained by the overhead of using the Futhark kernels.

More interesting is it to look at the execution time of the 2D version of the 
experiment. For all \sasmodels 2D experiments, we are not just calculating \iq
for each q, but actually $\sum_{q \in Q} \sum_{q \in Q} Iq(q_x, q_y)$.
So if we have $n$ q, we need to perform $n^2$ calculations.

We see in the figure, that Futhark at $10000^2$ datapoints now greatly outperforms
the Python model.

\begin{mdframed}[
  frametitle={Why does Futhark perform faster than Python?},
  nobreak=true
  ]
These comparisons are between Python/Numpy- and Futhark models.
Although Numpy can execute both of the models as vectorized calculations, 
it is still vastly outperformed by Futhark, which can run hundreds of threads 
simultaniously on the GPU.

## REFERENCER HER ##
\end{mdframed}

\subsection{Futhark vs. OpenCL performance}
\subsubsection{The \texttt{DAB} model}
The DAB model is relatively simple, as it is described as $I(q) = \frac{L^3}{1 + (qL)^2}$,
requiring us to work with just one single variable.
  \begin{figure}
    \begin{tikzpicture}
      \begin{axis}[
        mbarplot,
        title={1D performance},
        xlabel={number of datapoints},
        ylabel={Time in milliseconds},
        width=0.9\textwidth,
        height=\barheight,
        symbolic x coords={100,500,2500,5000,10000},
        bar width=9pt,
        enlargelimits=0.15,
        ybar=10pt,% configures ‘bar shift’
        bar width=12pt,
        nodes near coords,
        legend style={legend pos=north west}
      ]
      \addplot plot coordinates {(100, 0.54 ) (500, 0.74 ) (2500, 0.76 ) (5000, 0.74 ) (10000, 0.77 )};
      \addplot plot coordinates {(100, 0.86 ) (500, 0.85 ) (2500, 0.87 ) (5000, 0.87 ) (10000, 0.90 )};

      \legend{Current, Futhark}

      \end{axis}
    \end{tikzpicture}
    \begin{tikzpicture}
      \begin{axis}[
        mbarplot,
        title={2D performance},
        xlabel={number of datapoints},
        ylabel={Time in milliseconds},
        width=0.9\textwidth,
        height=\barheight,
        symbolic x coords={100,500,2500,5000,10000},
        bar width=9pt,
        enlargelimits=0.15,
        ybar=10pt,% configures ‘bar shift’
        bar width=12pt,
        nodes near coords,
        legend style={legend pos=north west}
      ]
      \addplot plot coordinates {(100, 0.78 ) (500, 1.61 ) (2500, 50.36 ) (5000, 196.19 ) (10000, 771.43 )};
      \addplot plot coordinates {(100, 0.90 ) (500, 1.75 ) (2500, 26.25 ) (5000, 101.59 ) (10000, 402.69 )};

      \legend{Current, Futhark}

      \end{axis}
    \end{tikzpicture}
    \label{fig:dab-graph}
    \caption{Comparison between OpenCL and Futhark performance for simple model}
  \end{figure}


\subsubsection{The \texttt{Core Shell Parallelepiped} model}
The Core Shell Parallelepiped model is by far one of the most complex models
in \sasmodels' catalogue.
With it's more than ten parameters and it's two nested loops, it is 
a candidate model for the Futhark compiler to attempt to optimize.
  \begin{figure}
    \begin{tikzpicture}
      \begin{axis}[
        mbarplot,
        title={1D performance},
        xlabel={number of datapoints},
        ylabel={Time in milliseconds},
        width=0.9\textwidth,
        height=\barheight,
        symbolic x coords={100,500,2500,5000,10000},
        bar width=9pt,
        enlargelimits=0.15,
        ybar=10pt,% configures ‘bar shift’
        bar width=12pt,
        nodes near coords,
        legend style={legend pos=north west}
      ]
      \addplot plot coordinates {(100, 20.88 ) (500, 21.19 ) (2500, 21.99) (5000, 22.44 ) (10000, 42.99)};
      \addplot plot coordinates {(100, 2.68 ) (500, 3.67 ) (2500, 8.00 ) (5000, 13.18 ) (10000,23.90 )};

      \legend{Current, Futhark}

      \end{axis}
    \end{tikzpicture}
    \begin{tikzpicture}
      \begin{axis}[
        mbarplot,
        title={2D performance},
        xlabel={number of datapoints},
        ylabel={Time in milliseconds},
        width=0.9\textwidth,
        height=\barheight,
        symbolic x coords={100,500,2500,5000,10000},
        bar width=9pt,
        enlargelimits=0.15,
        ybar=10pt,% configures ‘bar shift’
        bar width=12pt,
        nodes near coords,
        legend style={legend pos=north west}
      ]
      \addplot plot coordinates {(100, 0.83 ) (500, 2.17 ) (2500, 61.66 ) (5000, 232.32 ) (10000, 986.73 )};
      \addplot plot coordinates {(100, 2.04 ) (500, 2.88 ) (2500, 23.83 ) (5000, 91.87 ) (10000, 357.89 )};

      \legend{Current, Futhark}

      \end{axis}
    \end{tikzpicture}
    \label{fig:core-shell-graph}
    \caption{Comparison between OpenCL and Futhark performance for complex model}
  \end{figure}


  \begin{mdframed}[
    frametitle={Why does Futhark perform faster than OpenCL?},
    nobreak=true]
While it was expected to see Futhark outperform the strictly CPU based 
computations performed by Numpy in the Python models, it was more uncertain
how much (or even whether) Futhark would outperform OpenCL.

However, data shows that Futhark does perform better. The increased performance 
in figure \ref{fig:dab} is not really significant until we reach very high n,
which can be attributed to the simplicity of the model. With such simple models,
Futhark cannot really exploit any of the possible optimizations, but it can gain
some advantage by doing FUTHARK MAGI, which actually ends up roughly halving the 
execution time compared to the original implementation.

However, when we work with the rewritten core shell parallelepiped, we see huge
speedups even at n=100. This 
FUTHARK-MAGI HOISTING OG TING PÅ MAPS

\# show core-shell-whatever; and elaborate on loop flattening into maps
%%% MASSER AF REFERENCER TIL TROELS' PAPERS
\end{mdframed}


\section{Discussion, future work}
\label{sec:discussion}
The performance tests in \ref{performance} unequivocally shows, that
there are speedups to gain by running Futhark kernels in favor of Python or
OpenCL kernels.
In general, Futhark starts surpassing the performance of competing kernels, when
sample sizes rise above n=INDSÆT N. However, these gains are currently
irrelevant for the most \sasview use cases, as almost all
experiments are carried out on sample sizes of between 100-500.
However, meetings with external project owner Wojciech Potrzebowski lead to the
suggestion that simple bundling of \sasview experiments would enable us
to leverage the Futhark speed improvements directly.

In example, one could imagine running an experiment that continuously sends
sensor data for processing in \sasview / \sasmodels.
Instead of running an experiment for each sample\footnote{of size n=100-500}
from the stream, one could let \sasmodels bundle these input samples in packages
of 10-50 samples
instead, and calculate these collectively to leverage the speedups that are
apparent on Futhark calculations on samples of larger sizes.

Please note, that sample sizes might have an upper bound, depending on the
memory available on the workstations running the experiments.

\subsection{Finding best match in \sasview}
\label{sec:best-match}
In addition to bundling input data, Wojciech also did suggest that the Futhark
speedups could be used to implement faster best-match-finding for \sasview
experiments.

Among other things, \sasview is used to test multiple models against a data set,
to find out which of the models that actually fits the data most closely.
Currently this is not done in an efficient manner.
Therefore, it would be interesting to implement a way of running multiple models
on the same data set in parallel.
And given the current Futhark vs. OpenCL results, the implementation should
pursued in Futhark, as it has already been shown to be optimal
(compared to OpenCL).


\subsection{Usability of Futhark models}
It is relevant to discuss how useful Futhark models are to the \sasview user
groups. For the users who merely wants to use the models, it is not necessary
to understand the implementation itself at all, as the user facing part of
the model is just the model info file, which is just the same as the model infos
for Python and OpenCL models \ref{sec:using-futhark}.

However, for the model developer, it is now also necessary to have at least a
rudimentary understanding of functional programming.
In example, developers will have to learn how to use maps in
places where they would usually use loops.

Furthermore, the current solution requires severe amounts of boilerplate code to
be included in the futhark model file.
This boilerplate is caused by the usage of Futhark's module system, and
therefore not strictly part of defining i.e. the \iq function of a model.
The boilerplate might become a distraction for the model developer, so
there might be a smaller educational challenge to solve here as well.

\section{Conclusion}
To answer the questions raised in this project definition, it was first
necessary to implement a \sasmodels kernel for Futhark models. This was done
successfully and in a very non-destructive way in the already existing
\sasmodels code base.

The kernel itself (\texttt{kernelfut.py}) depends on the existing code base, but
the total change of the original code is two lines: an extra case in the
switch statement that decides which kernel type to run for a given model.

For Futhark model performances increases themselves, the results in
\ref{performances}, tells us that there are performance increase of between
200- and 2000 percent, depending on the original model's language and
complexity.

These gains are only realised when the sample size for a given run is high
enough, but section \ref{sec:discussion} has proposals for \sasmodels extensions
that could help \sasmodels users to reach these sample sizes, by bundling
experiments.

\begin{mdframed}[
  frametitle={Presentation at \sasview{} Code Camp},
  nobreak=true
  ]
Together with my supervisor and Futhark designer Troels Henriksen,
I was invited for an hour-long presentation and discussion of \futhark{} at the
yearly \textit{SasView Code Camp}, held at the Copenhagen Bio Science Park.\\\\
There was about 20 \sasview{} users and developers attending at the presentation,
which was about the definition and implementation of \futhark{}, along with
a presentation of the result performance boosts for selected models.\\\\
The project was well-received by the audience, and there was an eager discussion
of whether and how it could be possible to really exploit the Futhark
optimizations.\\\\
The primary suggestion was to leverage Futhark to find best-fitting models,
as described in \ref{sec:best-match}, but bundling continuous input from
a sensor to exploit Futhark speed ups at high n was also a feature that many
of the attendants expressed an interest in.
\end{mdframed}



% nævn at projektet er blevet præsenteret for en faktisk brugergruppe,
% og fik god og konstruktiv feedback
% det inspirerede til yderligere projekter/forbedringer indenfor sasmodels


\section*{Appendices}

\begin{figure}
  \lstinputlisting[language=Python, firstline=44,lastline=66]{../sasmodels/sasmodels/models/dab.py}
  \label{fig:dabmodel}
  \caption{The DAB model}
\end{figure}

\begin{figure}
  \lstinputlisting[language=Python, firstline=44, lastline=94]{../sasmodels/sasmodels/models/broad_peak.py}
  \label{fig:broadpeakmodel}
  \caption{The broad_peak model}
\end{figure}

\begin{figure}
  \lstinputlisting[language=Python, linerange={27-55,57-68}]{../sasmodels/sasmodels/models/line.py}
  \label{fig:linemodel}
  \caption{The line model}
\end{figure}

\begin{figure}
  \lstinputlisting[firstline=2, lastline=18]{../sasmodels/sasmodels/models/futharks/line_futhark.fut}
  \label{fig:linemodel-futhark}
  \caption{The line model written in Futhark}
\end{figure}

\begin{figure}
  \lstinputlisting[language=Python, firstline=27, lastline=49]{../sasmodels/sasmodels/models/line_futhark.py}
  \label{fig:linemodelinfo-futhark}
  \caption{The line model info file designating a Futhark path}
\end{figure}

\begin{figure}
  \lstinputlisting[language=Python, linerange={131-162}]{../sasmodels/sasmodels/models/core_shell_parallelepiped.py}
  \lstinputlisting[language=C, linerange={10-81}]{../sasmodels/sasmodels/models/core_shell_parallelepiped.c}
  \label{fig:core_shell}
  \caption{The original core\_shell\_parallelepiped model (Iq and form volume)}
\end{figure}

\end{document}